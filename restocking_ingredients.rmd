---
title: Restocking Ingredients and their location
output:
    html:
        meta:
            css: css/style.css
---


<details>
<summary><b>How to use</b></summary>
<p>
Search for <b>Effect</b> and <b>Location</b> to see what restocking merchants are nearby.
    <ul>
    <li>Type into a column search element to search in that column.</li>
    <li>Type into a global search element to search globally.</li>
    <li>Click on the waffle menu to show/hide columns (restock Count, Weight, or Cost)</li>
    <li>Use <b>;</b> as a separator to search for multiple effects</li>
    </ul>

<b>Examples</b>
    <ul>
    <li>There are two merchants stocking <b>Fortify Fatigue</b> ingredients in <b>Vivec</b></li>
    <li>There is only a single ingredient, Saltrice, having both <b>Restore Health</b> and <b>Restore Fatigue</b> effects (searching for <i>Restore Health;Restore Fatigue</i>)
    </ul>
</p>

</details> 


```{r, echo = FALSE}
litedown::vest(
    css = c("@npm/simple-datatables/dist/style", "@npm/simple-datatables/dist/column_filter"),
    js = "@npm/simple-datatables"
    )
```

::: {#restocking}
```{r, echo = FALSE}
csv = "restocking.csv"
if(!file.exists(csv)){
    source("src/get_restocking_ingredients.r")
    restocking = get_restocking_ingredients()
    write.csv(restocking, csv, row.names = FALSE)
    } else {
    restocking = read.csv(csv)
    }

names(restocking) = tools::toTitleCase(names(restocking))

# Sort
I(restocking[c("Ingredient", "Effect", "Merchant", "Location", "Count", "Weight", "Value")])
```
:::

```{js, type = "module", echo = FALSE}
const positive_effects = new Set([
    "Cure Blight Disease",
    "Cure Common Disease",
    "Cure Paralyzation",
    "Cure Poison",
    "Detect Animal",
    "Detect Enchantment",
    "Detect Key",
    "Dispel",
    "Feather",
    "Fire Shield",
    "Fortify Agility",
    "Fortify Attack",
    "Fortify Endurance",
    "Fortify Fatigue",
    "Fortify Health",
    "Fortify Intelligence",
    "Fortify Luck",
    "Fortify Magicka",
    "Fortify Personality",
    "Fortify Speed",
    "Fortify Strength",
    "Fortify Willpower",
    "Frost Shield",
    "Invisibility",
    "Levitate",
    "Light",
    "Lighning Shield",
    "Night Eye",
    "Reflect",
    "Resist Common Disease",
    "Resist Fire",
    "Resist Frost",
    "Resist Magicka",
    "Resist Poison",
    "Resist Shock",
    "Restore Agility",
    "Restore Endurance",
    "Restore Fatigue",
    "Restore Health",
    "Restore Intelligence",
    "Restore Luck",
    "Restore Magicka",
    "Restore Personality",
    "Restore Speed",
    "Restore Strength",
    "Restore Willpower",
    "Spell Absorption",
    "Swift Swim",
    "Telekinesis",
    "Water Breathing",
    "Water Walking"
    ]);

const negative_effects = new Set([
    "Burden",
    "Damage Intelligence",
    "Drain Agility",
    "Drain Endurance",
    "Drain Fatigue",
    "Drain Health",
    "Drain Intelligence",
    "Drain Luck",
    "Drain Magicka",
    "Drain Personality",
    "Drain Speed",
    "Drain Strength",
    "Drain Willpower",
    "Paralyze",
    "Poison",
    "Vampirism"
    ]);


const render_highlight = function(data, _cell, _dataIndex, _cellIndex) {
    if(!window.mixable_effects)
        return data[0].data;

    const values = data[0].data
        .split(/\s*,\s*/)
        .map(v => {
            if(window.mixable_effects.has(v)){
                if(positive_effects.has(v))
                    return `\<span class="highlight-positive"\>${v}\</span\>`;
                if(negative_effects.has(v))
                    return `\<span class="highlight-negative"\>${v}\</span\>`;
            }
            return v;
        }).join(", ");

    return values;
    }


let dataTable = new simpleDatatables.DataTable("#restocking > table", {
    perPage: 20,
    perPageSelect: [5, 10, 20, 50, ["All", 0]],
    searchItemSeparator: ";",
    searchQuerySeparator: ";",
    columns: [
        {select: 1, render: render_highlight},
        {select: [4, 5, 6], hidden: true}
        ],
    tableRender: (_data, table, type) => {
        if (type === "print") {
            return table
        }
        const tHead = table.childNodes[0]
        const filterHeaders = {
            nodeName: "TR",
            childNodes: tHead.childNodes[0].childNodes.map(
                (_th, index) => ({nodeName: "TH",
                    childNodes: [
                        {
                            nodeName: "INPUT",
                            attributes: {
                                class: "datatable-input",
                                type: "search",
                                "data-and": "true",
                                "data-columns": `[${index}]`
                            }
                        }
                    ]})
            )
        }
        tHead.childNodes.push(filterHeaders)
        return table
        }
    });


dataTable.on("datatable.search", (query, index) => {
    const ingredients = new Set();
    const counts = {};
    const mixable_effects = new Set();

    const rows = dataTable.data.data;
    for(const i of index){
        const ingredient = rows[i].cells[0].data[0].data;
        const effects = rows[i].cells[1].data[0].data.split(/\s*,\s*/);

        if(ingredients.has(ingredient))
            continue

        ingredients.add(ingredient)
        for(const effect of effects){
            counts[effect] = (counts[effect] || 0) + 1;
            if(counts[effect] > 1) mixable_effects.add(effect)
            }
        }

    window.mixable_effects = mixable_effects;
    dataTable.update();
    });


window.dataTable = dataTable;
window.columnFilter = simpleDatatables.addColumnFilter(
    dataTable
);
```
